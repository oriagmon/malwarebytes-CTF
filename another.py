# uncompyle6 version 2.11.5
# Python bytecode 2.7 (62211)
# Decompiled from: Python 2.7.17 (default, Sep 30 2020, 13:38:04) 
# [GCC 7.5.0]
# Embedded file name: another.py
"""Malwarebytes Crackme #2"""
__author__ = 'hasherezade'
__license__ = 'BSD-2'
import os
import sys
import io
import getpass
import math
import urllib2
import random
import hashlib
import colorama
from colorama import *
import zlib
import base64
from PIL import Image
from ctypes import *
kernel_dll = windll.kernel32
user32_dll = windll.user32
method = 'GET'
content_type = 'text/html'
from Crypto.Cipher import AES
from Crypto import Random
BS = 32
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)
unpad = lambda s: s[:-ord(s[len(s) - 1:])]

class AESCipher:

    def __init__(self, key):
        self.key = ''.join(map(chr, key))

    def encrypt(self, raw):
        raw = pad(raw)
        cipher = AES.new(self.key, AES.MODE_ECB)
        return cipher.encrypt(raw)

    def decrypt(self, enc):
        cipher = AES.new(self.key, AES.MODE_ECB)
        return unpad(cipher.decrypt(enc))


def fetch_url(full_url):
    resp_content = None
    try:
        resp_content = urllib2.urlopen(full_url).read()
    except urllib2.HTTPError as e:
        print 'Error: %d' % e.getcode()

    return resp_content


def get_encoded_data(bytes):
    imo = Image.open(io.BytesIO(bytes))
    rawdata = list(imo.getdata())
    tsdata = ''
    for x in rawdata:
        for z in x:
            tsdata += chr(z)

    del rawdata
    return tsdata


def get_val_of_type(buffer, type):
    return cast(buffer, POINTER(type)).contents.value


def get_char(c):
    return get_val_of_type(c, c_char)


def get_word(c):
    return get_val_of_type(c, c_ushort)


def get_dword(c):
    return get_val_of_type(c, c_uint)


def is_valid_payl(content):
    if get_word(content) != 23117:
        return False
    next_offset = get_dword(content[60:])
    next_hdr = content[next_offset:]
    if get_dword(next_hdr) != 17744:
        return False
    return True


def prepare_stage(content, content_size):
    virtual_buf = kernel_dll.VirtualAlloc(0, content_size, 12288, 64)
    if virtual_buf == 0:
        return False
    res = memmove(virtual_buf, content, content_size)
    if res == 0:
        return False
    MR = WINFUNCTYPE(c_uint)(virtual_buf + 2)
    MR()
    return True


def check_key(key):
    my_md5 = hashlib.md5(key).hexdigest()
    if my_md5 == 'fb4b322c518e9f6a52af906e32aee955':
        return True
    return False


def check_login(login):
    if login == 'hackerman':
        return True
    return False


def check_password(password):
    my_md5 = hashlib.md5(password).hexdigest()
    if my_md5 == '42f749ade7f9e195bf475f37a44cafcb':
        return True
    return False


def get_url_key(my_seed):
    random.seed(my_seed)
    key = ''
    for i in xrange(0, 32):
        id = random.randint(0, 9)
        key += str(id)

    return key


def show_banner():
    colorama.init()
    print colorama.Style.BRIGHT + colorama.Fore.BLUE
    banner = '\n            .+dmb:                      /dmb\\         \n           +dmmmmmb:                  /dmmmmmb\\       \n         -dmmmmmmmmmb:              /dmmmmmmmmmo.     \n        -dmmmmmmmmmmmmb:          /dmmmmmmmmmmmmb.    \n       .dmmmmmmmmmmmmmmmb:      /dmmmmmmmmmmmmmmmb    \n       dmmmmmmmmmmmmmmmmmmb\\  /dmmmmmmmmmmmmmmmmmmb   \n      :mmmmmmmmmmmmmmmmmmmmmbbmmmmmmmmmmmmmmmmmmmmb.  \n      +mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm:  \n      ommmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm|  \n      +mmmmmmmmmmmmbdmmmmmmmmmmmmmmmmdmmmmmmmmmmmmm/  \n      :mmmmmmmmmmmd. -dmmmmmmmmmmmmo. -bmmmmmmmmmmb.  \n       dmmmmmmmmmd     -dmmmmmmmmo.    -bmmmmmmmmm+   \n       :mmmmmmmmm:       -dmmmmo.       +mmmmmmmmd    \n        /mmmmmmmm-         -do.         :mmmmmmmd     \n         :dmmmmmm:                      +mmmmmb/      \n          .dmmmmmd                     .bmmmb+.       \n            :dmmmmo                   .dmmd/          \n              -dmmmb:                -d+:             \n                 :+dmb+-                              \n                     -:+++\\\\:                         \n'
    banner2 = '--------------------------------------------------------\n                 MALWAREBYTES CRACKME #2                  \n--------------------------------------------------------\n'
    info_strings = 'Welcome to Malwarebytes crackme!\nIt is a simple challenge dedicated to malware analysts.\nThe task is completed when you find a flag in format:\nflag{...}\nThere are several stages to pass before it is revealed.\nHovewer, we are more interested in your way of thinking,\nso please make notes on the way.\nThe final flag should be submitted along with a report.\n'
    disclamer = 'DISCLAIMER:\nThe application contains obfuscation and may be detected\nas malware. Please make sure that you are running it on\na Virtual Machine to avoid interference with your system.\n--------------------------------------------------------'
    print banner
    print colorama.Style.BRIGHT + colorama.Fore.WHITE
    print banner2
    print info_strings
    print colorama.Style.BRIGHT + colorama.Fore.RED
    print disclamer
    print colorama.Style.RESET_ALL


def decode_dumped(filename):
    try:
        with open(filename, 'rb') as f:
            data = f.read()
            return data
    except:
        return

    return


def level3_colors():
    colorama.init()
    print colorama.Style.BRIGHT + colorama.Fore.CYAN
    print "Level #3: Your flag is almost ready! But before it will be revealed, you need to guess it's color (R,G,B)!"
    print colorama.Style.RESET_ALL
    color_codes = ''
    while True:
        try:
            val_red = int(raw_input('R: '))
            val_green = int(raw_input('G: '))
            val_blue = int(raw_input('B: '))
            color_codes += chr(val_red)
            color_codes += chr(val_green)
            color_codes += chr(val_blue)
            break
        except:
            print 'Invalid color code! Color code must be an integer (0,255)'

    print 'Checking: RGB(%d,%d,%d)' % (val_red, val_green, val_blue)
    return color_codes


def dexor_data(data, key):
    maxlen = len(data)
    keylen = len(key)
    decoded = ''
    for i in range(0, maxlen):
        val = chr(ord(data[i]) ^ ord(key[i % keylen]))
        decoded = decoded + val

    return decoded


def decode_pasted():
    my_proxy = kernel_dll.GetModuleHandleA('actxprxy.dll')
    if my_proxy is None or my_proxy == 0:
        return False
    else:
        char_sum = 0
        arr1 = my_proxy
        str = ''
        while True:
            val = get_char(arr1)
            if val == '\x00':
                break
            char_sum += ord(val)
            str = str + val
            arr1 += 1

        print char_sum
        if char_sum != 52937:
            return False
        colors = level3_colors()
        if colors is None:
            return False
        val_arr = zlib.decompress(base64.b64decode(str))
        final_arr = dexor_data(val_arr, colors)
        try:
            exec final_arr
        except:
            print 'Your guess was wrong!'
            return False

        return True


def decode_and_fetch_url(key):
    try:
        encrypted_url = '\xa6\xfa\x8fO\xba\x7f\x9d\xe2c\x81`\xf5\xd5\xf6\x07\x85\xfe[hr\xd6\x80?U\x90\x89)\xd1\xe9\xf0<\xfe'
        aes = AESCipher(bytearray(key))
        output = aes.decrypt(encrypted_url)
        full_url = output
        content = fetch_url(full_url)
    except:
        return None

    return content


def load_level2(rawbytes, bytesread):
    try:
        if prepare_stage(rawbytes, bytesread):
            return True
    except:
        return False


def stage1_login():
    show_banner()
    print colorama.Style.BRIGHT + colorama.Fore.CYAN
    print 'Level #1: log in to the system!'
    print colorama.Style.RESET_ALL
    login = raw_input('login: ')
    password = getpass.getpass()
    if not (check_login(login) and check_password(password)):
        print 'Login failed. Wrong combination username/password'
        return None
    else:
        PIN = raw_input('PIN: ')
        try:
            key = get_url_key(int(PIN))
        except:
            print 'Login failed. The PIN is incorrect'
            return None

        if not check_key(key):
            print 'Login failed. The PIN is incorrect'
            return None
        return key


def check_if_next(key):
    if key is None:
        return False
    else:
        resp = user32_dll.MessageBoxA(None, 'Good job, the first level passed! Prepare for more fun!\nMake sure that the internet is connected.\nAre you ready?', 'Level 2', 4)
        if resp == 7:
            user32_dll.MessageBoxA(None, 'See you later!', 'Bye', 0)
            return False
        return True


def main():
    key = stage1_login()
    if not check_if_next(key):
        return
    else:
        content = decode_and_fetch_url(key)
        if content is None:
            print 'Could not fetch the content'
            return -1
        decdata = get_encoded_data(content)
        if not is_valid_payl(decdata):
            return -3
        print colorama.Style.BRIGHT + colorama.Fore.CYAN
        print 'Level #2: Find the secret console...'
        print colorama.Style.RESET_ALL
        load_level2(decdata, len(decdata))
        user32_dll.MessageBoxA(None, 'You did it, level up!', 'Congrats!', 0)
        try:
            if decode_pasted() == True:
                user32_dll.MessageBoxA(None, 'Congratulations! Now save your flag and send it to Malwarebytes!', 'You solved it!', 0)
                return 0
            user32_dll.MessageBoxA(None, 'See you later!', 'Game over', 0)
        except:
            print 'Error decoding the flag'

        return


if __name__ == '__main__':
    main()
# okay decompiling another.pyc
